name: Craftista Multi-Stage Pipeline

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [develop]
    paths:
      - 'frontend/**'
      - 'catalogue/**'
      - 'voting/**'
      - 'recommendation/**'

  # push:
  #   branches: [develop]
  #   paths:
  #     - 'frontend/**'
  #     - 'catalogue/**'
  #     - 'voting/**'
  #     - 'recommendation/**'

env:
  REGISTRY: docker.io
  IMAGE_PREFIX: craftista
  AWS_REGION: us-east-1
  EKS_CLUSTER: craftista-demo-cluster

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      frontend: ${{ steps.changes.outputs.frontend }}
      catalogue: ${{ steps.changes.outputs.catalogue }}
      recommendation: ${{ steps.changes.outputs.recommendation }}
      voting: ${{ steps.changes.outputs.voting }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            frontend:
              - 'frontend/**'
            catalogue:
              - 'catalogue/**'
            recommendation:
              - 'recommendation/**'
            voting:
              - 'voting/**'
            docker:
              - 'docker-compose.yml'

  validate-frontend:
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.frontend == 'true' }}
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      - name: Install dependencies
        run: npm ci --legacy-peer-deps
      - name: Lint
        run: npm run lint || true
      - name: Run unit tests
        run: npm run test:coverage
      - name: SonarCloud Analysis
        uses: SonarSource/sonarqube-scan-action@v4
        with:
          projectBaseDir: frontend
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  validate-catalogue:
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.catalogue == 'true' }}
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: catalogue
    steps:
      - uses: actions/checkout@v4
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: catalogue/requirements.txt
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt pytest pytest-cov bandit safety
      - name: Run unit tests with coverage
        run: pytest --cov=. --cov-report=xml
      - name: SonarCloud Analysis
        uses: SonarSource/sonarqube-scan-action@v4
        with:
          projectBaseDir: catalogue
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  validate-recommendation:
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.recommendation == 'true' }}
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: recommendation
    steps:
      - uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
          cache-dependency-path: recommendation/go.sum
      - name: Install dependencies
        run: go mod download
      - name: SonarCloud Analysis
        uses: SonarSource/sonarqube-scan-action@v4
        with:
          projectBaseDir: recommendation
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  validate-voting:
    needs: detect-changes
    if: ${{ needs.detect-changes.outputs.voting == 'true' }}
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: voting
    steps:
      - uses: actions/checkout@v4
      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'
      - name: Build and test
        run: mvn -B verify
      - name: SonarCloud Analysis
        run: mvn sonar:sonar
        working-directory: voting
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  
  build-and-push-frontend:
    runs-on: ubuntu-latest
    needs: validate-frontend
    if: ${{ needs.detect-changes.outputs.frontend == 'true' }}
    steps:
      - uses: actions/checkout@v4
      - name: Generate date-based version tag
        id: version
        run: |
          # Generate timestamp in YYYYMMDD-HHMMSS format
          TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
          echo "VERSION=${TIMESTAMP}" >> $GITHUB_OUTPUT
          # Get previous version for potential rollback
          PREV_VERSION=$(curl -s "https://hub.docker.com/v2/repositories/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-frontend/tags/" | jq -r '.results[1].name')
          echo "PREV_VERSION=${PREV_VERSION}" >> $GITHUB_OUTPUT
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Build and Push Docker Image
        id: docker_push
        run: |
          echo "Building and pushing frontend..."
          VERSION_TAG=${{ steps.version.outputs.VERSION }}
          docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-frontend:latest -t ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-frontend:${VERSION_TAG} ./frontend
          if ! docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-frontend:latest || \
            ! docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-frontend:${VERSION_TAG}; then
            echo "PUSH_FAILED=true" >> $GITHUB_OUTPUT
            exit 1
          fi
      - name: Rollback on failure
        if: failure() && steps.docker_push.outputs.PUSH_FAILED == 'true'
        run: |
          echo "Docker push failed. Initiating rollback procedure..."
          PREV_VERSION=${{ steps.version.outputs.PREV_VERSION }}
          if [ ! -z "$PREV_VERSION" ]; then
            echo "Rolling back to version: $PREV_VERSION"
            # Pull previous version
            docker pull ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-frontend:${PREV_VERSION}
            # Tag it as latest
            docker tag ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-frontend:${PREV_VERSION} ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-frontend:latest
            # Push latest tag
            if docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-frontend:latest; then
              echo "Rollback completed successfully"
            else
              echo "::error::Rollback failed. Manual intervention required."
              exit 1
            fi
          else
            echo "::error::No previous version found for rollback. Manual intervention required."
            exit 1
          fi
      - name: Notify failure
        if: failure()
        run: |
          echo "::error::Frontend service deployment failed. Status: $([ "${{ steps.docker_push.outputs.PUSH_FAILED }}" == "true" ] && echo "Rollback attempted" || echo "Build failed")"

  build-and-push-catalogue:
    runs-on: ubuntu-latest
    needs: validate-catalogue
    if: ${{ needs.detect-changes.outputs.catalogue == 'true' }}
    steps:
      - uses: actions/checkout@v4
      - name: Generate date-based version tag
        id: version
        run: |
          TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
          echo "VERSION=${TIMESTAMP}" >> $GITHUB_OUTPUT
          PREV_VERSION=$(curl -s "https://hub.docker.com/v2/repositories/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-catalogue/tags/" | jq -r '.results[1].name')
          echo "PREV_VERSION=${PREV_VERSION}" >> $GITHUB_OUTPUT
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Build and Push Docker Image
        id: docker_push
        run: |
          echo "Building and pushing catalogue..."
          VERSION_TAG=${{ steps.version.outputs.VERSION }}
          docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-catalogue:latest -t ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-catalogue:${VERSION_TAG} ./catalogue
          if ! docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-catalogue:latest || \
            ! docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-catalogue:${VERSION_TAG}; then
            echo "PUSH_FAILED=true" >> $GITHUB_OUTPUT
            exit 1
          fi
      - name: Rollback on failure
        if: failure() && steps.docker_push.outputs.PUSH_FAILED == 'true'
        run: |
          echo "Docker push failed. Initiating rollback procedure..."
          PREV_VERSION=${{ steps.version.outputs.PREV_VERSION }}
          if [ ! -z "$PREV_VERSION" ]; then
            echo "Rolling back to version: $PREV_VERSION"
            docker pull ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-catalogue:${PREV_VERSION}
            docker tag ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-catalogue:${PREV_VERSION} ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-catalogue:latest
            if docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-catalogue:latest; then
              echo "Rollback completed successfully"
            else
              echo "::error::Rollback failed. Manual intervention required."
              exit 1
            fi
          else
            echo "::error::No previous version found for rollback. Manual intervention required."
            exit 1
          fi
      - name: Notify failure
        if: failure()
        run: |
          echo "::error::Catalogue service deployment failed. Status: $([ "${{ steps.docker_push.outputs.PUSH_FAILED }}" == "true" ] && echo "Rollback attempted" || echo "Build failed")"

  build-and-push-recommendation:
    runs-on: ubuntu-latest
    needs: validate-recommendation
    if: ${{ needs.detect-changes.outputs.recommendation == 'true' }}
    steps:
      - uses: actions/checkout@v4
      - name: Generate date-based version tag
        id: version
        run: |
          TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
          echo "VERSION=${TIMESTAMP}" >> $GITHUB_OUTPUT
          PREV_VERSION=$(curl -s "https://hub.docker.com/v2/repositories/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-recommendation/tags/" | jq -r '.results[1].name')
          echo "PREV_VERSION=${PREV_VERSION}" >> $GITHUB_OUTPUT
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Build and Push Docker Image
        id: docker_push
        run: |
          echo "Building and pushing recommendation..."
          VERSION_TAG=${{ steps.version.outputs.VERSION }}
          docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-recommendation:latest -t ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-recommendation:${VERSION_TAG} ./recommendation
          if ! docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-recommendation:latest || \
            ! docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-recommendation:${VERSION_TAG}; then
            echo "PUSH_FAILED=true" >> $GITHUB_OUTPUT
            exit 1
          fi
      - name: Rollback on failure
        if: failure() && steps.docker_push.outputs.PUSH_FAILED == 'true'
        run: |
          echo "Docker push failed. Initiating rollback procedure..."
          PREV_VERSION=${{ steps.version.outputs.PREV_VERSION }}
          if [ ! -z "$PREV_VERSION" ]; then
            echo "Rolling back to version: $PREV_VERSION"
            docker pull ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-recommendation:${PREV_VERSION}
            docker tag ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-recommendation:${PREV_VERSION} ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-recommendation:latest
            if docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-recommendation:latest; then
              echo "Rollback completed successfully"
            else
              echo "::error::Rollback failed. Manual intervention required."
              exit 1
            fi
          else
            echo "::error::No previous version found for rollback. Manual intervention required."
            exit 1
          fi
      - name: Notify failure
        if: failure()
        run: |
          echo "::error::Recommendation service deployment failed. Status: $([ "${{ steps.docker_push.outputs.PUSH_FAILED }}" == "true" ] && echo "Rollback attempted" || echo "Build failed")"

  build-and-push-voting:
    runs-on: ubuntu-latest
    needs: validate-voting
    if: ${{ needs.detect-changes.outputs.voting == 'true' }}
    steps:
      - uses: actions/checkout@v4
      - name: Generate date-based version tag
        id: version
        run: |
          TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
          echo "VERSION=${TIMESTAMP}" >> $GITHUB_OUTPUT
          PREV_VERSION=$(curl -s "https://hub.docker.com/v2/repositories/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-voting/tags/" | jq -r '.results[1].name')
          echo "PREV_VERSION=${PREV_VERSION}" >> $GITHUB_OUTPUT
      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      - name: Build and Push Docker Image
        id: docker_push
        run: |
          echo "Building and pushing voting..."
          VERSION_TAG=${{ steps.version.outputs.VERSION }}
          docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-voting:latest -t ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-voting:${VERSION_TAG} ./voting
          if ! docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-voting:latest || \
            ! docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-voting:${VERSION_TAG}; then
            echo "PUSH_FAILED=true" >> $GITHUB_OUTPUT
            exit 1
          fi
      - name: Rollback on failure
        if: failure() && steps.docker_push.outputs.PUSH_FAILED == 'true'
        run: |
          echo "Docker push failed. Initiating rollback procedure..."
          PREV_VERSION=${{ steps.version.outputs.PREV_VERSION }}
          if [ ! -z "$PREV_VERSION" ]; then
            echo "Rolling back to version: $PREV_VERSION"
            docker pull ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-voting:${PREV_VERSION}
            docker tag ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-voting:${PREV_VERSION} ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-voting:latest
            if docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-voting:latest; then
              echo "Rollback completed successfully"
            else
              echo "::error::Rollback failed. Manual intervention required."
              exit 1
            fi
          else
            echo "::error::No previous version found for rollback. Manual intervention required."
            exit 1
          fi
      - name: Notify failure
        if: failure()
        run: |
          echo "::error::Voting service deployment failed. Status: $([ "${{ steps.docker_push.outputs.PUSH_FAILED }}" == "true" ] && echo "Rollback attempted" || echo "Build failed")"    


# _________________________________________________________________________________

  deploy-to-staging:
    needs: [build-and-push-frontend, build-and-push-catalogue, build-and-push-recommendation, build-and-push-voting]
    if: |
      github.event_name == 'pull_request' && 
      github.event.pull_request.merged == true && 
      github.base_ref == 'develop'
    runs-on: ubuntu-latest
    environment: 
      name: staging
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Deploy to staging
        id: deploy
        run: |
          # Apply namespace
          kubectl apply -f k8s/staging/namespace.yaml
          
          # Deploy services
          for service in frontend catalogue recommendation voting; do
            if [[ -f "k8s/staging/${service}.yaml" ]]; then
              VERSION_TAG=$(curl -s "https://hub.docker.com/v2/repositories/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-${service}/tags/" | jq -r '.results[0].name')
              sed -i "s|image: ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-${service}:.*|image: ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-${service}:${VERSION_TAG}|g" k8s/staging/${service}.yaml
              kubectl apply -f k8s/staging/${service}.yaml
            fi
          done

      - name: Verify staging deployment
        run: |
          for service in frontend catalogue recommendation voting; do
            echo "Waiting for ${service} deployment to complete..."
            kubectl rollout status deployment/${service} -n craftista-staging --timeout=300s
          done

      - name: Rollback on failure
        if: failure() && steps.deploy.outcome == 'failure'
        run: |
          echo "Deployment failed, rolling back..."
          for service in frontend catalogue recommendation voting; do
            if kubectl get deployment ${service} -n craftista-staging &> /dev/null; then
              kubectl rollout undo deployment/${service} -n craftista-staging
            fi
          done

  promote-to-production:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: 
      name: production
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Validate staging environment
        run: |
          for service in frontend catalogue recommendation voting; do
            if ! kubectl get deployment ${service} -n craftista-staging &> /dev/null; then
              echo "Error: ${service} not found in staging"
              exit 1
            fi
            
            READY=$(kubectl get deployment ${service} -n craftista-staging -o jsonpath='{.status.readyReplicas}')
            DESIRED=$(kubectl get deployment ${service} -n craftista-staging -o jsonpath='{.spec.replicas}')
            
            if [ "$READY" != "$DESIRED" ]; then
              echo "Error: ${service} not ready in staging"
              exit 1
            fi
          done

      - name: Store current production state
        run: |
          mkdir -p /tmp/rollback
          for service in frontend catalogue recommendation voting; do
            kubectl get deployment ${service} -n craftista-production -o yaml > /tmp/rollback/${service}.yaml || true
          done

      - name: Promote to production
        id: promote
        run: |
          # Apply production namespace
          kubectl apply -f k8s/production/namespace.yaml
          
          # For each service, get the image tag from staging and apply to production
          for service in frontend catalogue recommendation voting; do
            if [[ -f "k8s/production/${service}.yaml" ]]; then
              # Get current image tag from staging deployment
              STAGING_TAG=$(kubectl get deployment ${service} -n craftista-staging -o jsonpath='{.spec.template.spec.containers[0].image}' | cut -d ':' -f2)
              
              # Update production manifest with staging tag
              sed -i "s|image: ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-${service}:.*|image: ${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_PREFIX }}-${service}:${STAGING_TAG}|g" k8s/production/${service}.yaml
              
              # Apply to production
              kubectl apply -f k8s/production/${service}.yaml
            fi
          done

      - name: Verify production deployment
        run: |
          for service in frontend catalogue recommendation voting; do
            echo "Waiting for ${service} deployment to complete..."
            kubectl rollout status deployment/${service} -n craftista-production --timeout=300s
          done

      - name: Rollback on failure
        if: failure() && steps.promote.outcome == 'failure'
        run: |
          echo "Promotion failed, rolling back..."
          for service in frontend catalogue recommendation voting; do
            if [ -f "/tmp/rollback/${service}.yaml" ]; then
              kubectl apply -f /tmp/rollback/${service}.yaml
            fi
          done

      - name: Notify deployment status
        if: always()
        run: |
          STATUS="${{ job.status }}"
          ENVIRONMENT="${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}"
          
          if [ "$STATUS" = "success" ]; then
            echo "Deployment to ${ENVIRONMENT} completed successfully"
          else
            echo "Deployment to ${ENVIRONMENT} failed"
            exit 1
          fi